## 目录

## 交易型系统的一些设计原则

###   高并发原则
*  无状态
*  拆分
*  服务化
*  消息队列
*  数据异构
*  缓存银弹
*  并发化

### 高可用原则
* 降级
* 限流
* 切流量
* 可回滚

### 业务设计原则
* 防重设计
* 幂等设计
* 流程可定义
* 状态和状态机
* 后台系统操作可反馈
* 后台系统审批化
* 文档和注释
* 备份

# 高可用

### 负载均衡和反向代理
 * upstream 配置
 * 负载均衡算法
 * 失败重试
 * 健康检查  
    心跳： tcp、http
 * 其他配置
    域名上游服务器、备份上游服务器、不可用上游服务器
 * 长链接
 * http反向代理
 * http 动态负载均衡
   consul+consul+template 、consul+openresty
 * nginx 四层负载均衡
    静态负载均衡、动态负载均衡
### 隔离术
* 线程隔离
* 进程隔离
* 集群隔离
* 机房隔离
* 读写隔离
* 动静隔离
* 爬虫隔离
* 热点隔离
* 资源隔离
* 使用hystrix隔离 
   hystrix简介、隔离事例
* 基于servlet3实现请求隔离
 1 请求解析和业务处理线程池分离
 2 业务线程池隔离
 3 业务线程池监控/运维/降级
 4 如何使用servlet3异步化 
 5 一些servlet3 异步化压测数据
 
## 限流详解
 
### 限流算法 
  * 令牌桶算法
  * 漏桶算法
### 应用级限流
  * 限流总并发、链接、请求数 
  * 限流总资源数
  * 限流某个接口的总并发、请求数
  * 限流某个接口的时间窗口请求数
  * 平滑限流某个接口的请求数
  
### 分布式限流
  * redis+lua
  * nginx+lua
### 接入层限流
  * ngx_http_limit_conn_module
  * ngx_http_limit_req_module
  * lua_resty-limit-traffic
  
### 节流
   * throttleFirst/throttleLast
   * throttleWithTimeout

## 降级特技
  * 降级预案
  * 自动开关降级
    1 超时降级
    2 统计失败次数降级
    3 故障降级
    4 限流降级
  * 人工开关降级
  * 读服务降级
  * 写服务降级
  * 多级降级
  * 配置中心
     1 应用层api封装
     2 使用配置文件实现开关配置
     3 使用配置中心实现开关配置
  * 使用hystrix 实现降级
  * 使用hystrix 实现熔断
     1 熔断机制实现
     2 配置示例
     3 采样统计
 ## 超时与重试机制
 
   * 简介
   * 代理层超时与重试
     1 nginx
     2 twemproxy
   * web容器超时与重试 
   * 数据库客户端超时
   * nosql 客户端超时
   * 业务超时
   * 前端ajax超时
   * 总结&参考资料
   
## 回滚机制
   * 事务回滚
   * 代码库回滚
   * 部署版本回滚
   * 数据版本回滚
   * 静态资源版本回滚
   
## 压测与预案
   * 系统压测
     online/offline
   * 系统优化与容灾
   * 应急预案
   
# 高并发
   
   
   
  
 
 
 
 
 
 








   
 
 
 
 
