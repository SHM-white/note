# 线程和同步的性能

## 线程池与 ThreadPoolExecutor
###  设置最大线程数
###  设置最小线程数
###  线程池任务大小
###  设置 ThreadPoolExecutor 的大小
* SynchronousQueue
* LinkedBlockedingQueue
* ArrayBlockingQueue

1. 有时对象池也是不错的选择，线程池就是情形之一：线程初始化的成本很高，线程池使得系统上的线程数容易控制。
2. 线程池必须仔细调优。盲目向池中添加新线程，在某些情况下对性能会有不利影响。
3. 在使用 ThreadPoolExecutor 时，选择更简单的选项通常会带来最好的、最能预见的性能。

## ForkJoinPool
分治算法
### 自动并行化
1. ForkJoinPool 类应该用于递归、分治算法。
2. 应该花些心思来确定，算法中的递归任务何时结束最为合适。创建太多任务会降低性能，但如果任务太少，而任务所需的执行时间又长短不一，
也会降低性能。
3. Java 8 中使用了自动并行化的特性会用到一个公共的 ForkJoinPool 实例。我们可能需要根据实际情况调整这个实例的默认大小。

## 线程同步
### 同步的代价
* 同步与可伸缩性
* 锁定对象的开销

1. 线程同步有两个性能方面的代价：限制了应用的可伸缩性，以及获取锁
是有开销的。
2. 同步的内存语义、基于 CAS 的设施和 volatile 关键字对性能可能会有
很大的影响，特别是在有很多寄存器的大型机上
### 避免同步
* 如果访问的是不存在竞争的资源，那么基于 CAS 的保护要稍快于传统的同步（虽然完
全不使用保护会更快）。
* 如果访问的资源存在轻度或适度的竞争，那么基于 CAS 的保护要快于传统的同步（而
且往往是快得多）。
* 随着所访问资源的竞争越来越剧烈，在某一时刻，传统的同步就会成为更高效的选择。
在实践中，这只会出现在运行着大量线程的非常大型的机器上。
* 当被保护的值有多个读取，但不会被写入时，基于 CAS 的保护不会受竞争的影响。

1. 避免对同步对象的竞争，是缓解同步对性能影响的有效方式之一。
2. 线程局部变量不会受竞争之苦；对于保存实际不需要在多个线程间共享的同步对象，它们非常理想。
3. 对于确实需要共享的对象，基于 CAS 的工具也是避免传统的同步的方式之一。

### 伪共享
1. 对于会频繁地修改 volatile 变量或退出同步块的代码，伪共享对性能影响很大。
2. 伪共享很难检测。如果某个循环看上去非常耗时，可以检查该代码，看看是否与伪共享出现时的模式相匹配。
3. 最好通过将数据移到局部变量中、稍后再保存来避免伪共享。作为一种替代方案，有时可以使用填充将冲突的变量移到不同的缓存行中

## JVM线程调优
### 调节线程栈大小
1. 在内存比较稀缺的机器上，可以减少线程栈大小。
2. 在 32 位的 JVM 上，可以减少线程栈大小，以便在 4 GB 进程空间限制的
条件下，稍稍增加堆可以使用的内存。
### 偏向锁
 -XX:-UseBiasedLocking   
 
### 自旋锁
 -XX:+UseSpinning   java8 noy support
### 线程优先级

## 监控线程与锁
### 查看线程
jconsole 
### 查看阻塞线程
1. 被阻塞线程与JFR 
2. 被阻塞线程与 JStack

1. 利用系统提供的线程基本信息，可以对正在运行的线程的数目有个大致了解。
2. 就性能分析而言，当线程阻塞在某个资源或 I/O 上时，能够看到线程的相关细节就显得比较重要。
3. JFR 使得我们可以很方便地检查引发线程阻塞的事件。
4 利用 jstack，一定程度上可以检查线程是阻塞在什么资源上
