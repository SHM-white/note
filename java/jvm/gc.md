# 垃圾收集入门

## 主流垃圾回收收集器
*　Serial收集器 
*　Throughput(Parallel)收集器
*　Concurrent(CMS)收集器
*　G1收集器
cms 与g1 称为concurrent垃圾收集器，属于低停顿收集器，当然也有代价就是消耗更多的cpu

## 概述
垃圾收集主要分两部 1 查找不再使用的对象 2 以及如何释放这些对象的内存
### 分代垃圾收集器
* 新生代
1. eden
2. survivor   
   form 、to 
* 老年代
当新生代的内存填满时会发生minor gc,这种方式的好处有两个1新生代仅仅是堆的一部分，与处理整个堆相比，处理新生代的速度更快
意味着应用线程停顿的时间也越短(stw),但是停顿的次数会变多。2 源于新生代中对象的分配方式，对象分配到eden空间　垃圾收集时
eden空间的对象要么移走要么被回收,所有存活的对象要么被移动survivor空间要么被移动到老年代，这回自动产生了一次压缩整理，最终
老年代也会不断的变大，然后开始回收老年代，full gc产生，通常会导致应用长时间的停顿
考虑垃圾收集器 主要考虑单个请求与批量应用进行考量
### GC算法
1. Serial垃圾收集器
2. Throughput垃圾收集器
3. CMS收集器
4. G1垃圾收集器
### 选择GC算法
耗时、吞吐量、平均响应时间
* GC算法及批量任务
* GC算法和吞吐量测试
* GC算法及响应时间测试
* CMS收集器和G1收集器之间的抉择
## GC调优基础
###  调整堆的大小
堆的大小影响系统停顿的时间    
首个原则就是尽量不要把堆的大小设置大于机器的物理内存    
 虽然可以大于，但是GC会以数个数量级的停顿时间    
两个参数     
* 初始值 -xms
* 最大值 -xmx

###  代空间的调整
新生代过大，导致回收次数变少，full gc可能相应的变多
1. 新生代空间调整
-XX:NewRatio=N 设置新生代与老年代的空间占用比率 默认为2
-XX:NewSize=N  设置新生代初始化的值
-XX:MaxNewSize=N 设置新生代空间的最大大小
-XmnN   快捷方法 new & max    
计算公式:   
Initial Young Gen Size = Initial Heap Size / (1 + NewRatio)     
默认情况下 新生代占初始堆大小的33%

###  永久代与元空间的调整
###  控制并发
###  自适应调整

## 垃圾回收工具

