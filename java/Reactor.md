# Reactor
>在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式  
>其中Reactor模式用于同步I/O，而Proactor运用于异步I/O操作

##  什么是同步和异步?  
>同步和异步是针对应用程序和内核的交互而言的，消息通知机制而言
>同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪  
>异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知  
### 消息通知
>异步的概念和同步相对。当一个同步调用发出后，调用者要一直等待返回消息（结果）通知后，才能进行后续的执行；当一个异步过程调用发出后，调
> 用者不能立刻得到返回消息（结果）。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者
> 具体实现依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制
1. 如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，
   总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）；  
2. 如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。
##  什么是阻塞和非阻塞?
>阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式， 
说白了是一种读取或者写入操作函数的实现方式   
 阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务
>阻塞方式下读取或者写入函数将一直等待 
>非阻塞方式下，读取或者写入函数会立即返回一个状态值   
非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。
虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，但是也带了另外一种后果就是系统的线程切换增加。
增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。

## 四种I/O模型
  1. 同步阻塞
  >在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成,
   只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！
  2. 同步非阻塞
  >在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，
  这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。
  3. 异步阻塞  
  >此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，
  同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，
  而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！  
  异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞  
  4. 异步非阻塞IO
  >在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，
  此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，
  因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。
  
# Reactor
 > 读取操作：
>1. 应用程序注册读就需事件和相关联的事件处理器

>2. 事件分离器等待事件的发生

>3. 当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器

>4. 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理
# Proactor
 > 读取
>1. 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。

>2. 事件分离器等待读取操作完成事件

>3. 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。

>4. 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。
# Reactor和Proactor模式的主要区别
> 从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，
  Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，
  它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备.  

 >同步和异步仅仅是关注的消息如何通知的机制，而阻塞与非阻塞关注的是等待消息通知时的状态。也就是说，同步的情况下，是由处理消息者自己去等待消息是否被触发，而异步的情况下是由触发机制来通知处理消息者，所以在异步机制中，处理消息者和触发机制之间就需要一个连接的桥梁  
 而阻塞和非阻塞仅仅是系统在调用系统调用的时候函数的实现方式而已。

 
 [reactor和proactor模式（epoll和iocp）](http://blog.csdn.net/zccracker/article/details/38686339)
 [聊聊同步、异步、阻塞与非阻塞](https://www.jianshu.com/p/aed6067eeac9)
 
