# java memory model

##  并发编程模型的分类

 > 并发中两个关键问题   
  1. 线程之间如何通信   
  2. 线程之间如何同步      
  
 通信是指线程之间以何种机制来交换信息，命令式编程中的通信机制主要有两种，共享内存和消息传递      
 在线程共享的并发模型中 ，线程共享程序的公共状态，线程如何通过读写内存中的公共状态来隐式的通信    
 在消息传递的并发模型中，线程之间必须通过明确的的发送消息来显示的通信     
 同步是指程序用于控制不同线程之间操作发生相对顺序的机制，so 在共享内存并发模式下，同步是显示的，程序员
必须显示指定某个方法或某段代码需要线程之间互斥。在消息传递的并发模型下，由于消息的发送在消息的接收之前，因此
同步是隐式进行的。    
java 使用的共享内存模型，线程之间通信是隐式的，整个通信过程对程序员是透明的

## java内存的模型抽象
首先要知道，在java中 实例域、静态域、数组元素存储在堆上，堆内存在线程之间共享，局部变量，方法定义参数和异常处理参数不会在线程之间
共享，不会存在内存可见性问题，也不受内存模型的影响。

java线程之间通信由jmm (java 内存模型)控制，jmm决定一个线程对共享变量的写入何时对另一个线程可见，抽象角度看jmm定义了线程和主内存
之间的抽象关系：线程之间的共享变量存储在主内存(main memory)中,每一个线程都有一个私有的本地内存(local memory),本地内存
存储了该线程以读/写共享变量的副本。本地缓存是jmm的一个抽象概念，并不真实存在，它涵盖了缓冲，写缓冲区，寄存器以及其他的硬件和编译器优化      
![jmm]()    


## 重排序

什么是重排序？为什么要重新排序？    
程序指令排序，为了提高性能。
分类:   
1. 编译器优化的重排序
       在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序
2. 指令级的重排序
  现代的处理器采用了指令级并行技术来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的顺序
3. 内存系统的重排序
   由于处理使用缓存读和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行      
   
java 从代码到指令排序分别会经历下面三种排序        
!['三种排序']()    
对于编译器，jmm的编译器重排序规则会禁止特定类型的编译器重排序，对于处理器重排序，jmm的重排序规则要求java编译在生成   
指令序列时，插入指定类型的内存屏障，用来禁止指定类型的处理器重排序。

## 处理器重排序和内存屏障指令

现在的处理器使用写缓冲区来临时保存向内存写入的数据，保证指令流水线执行，避免等待写缓存的延时
p-1  a = 1; x =b;   
p-2  b = 1; y =b;   
最后结果就是 x=y=0,具体的1、写缓冲区 2、读共享变量 3、刷新写缓冲区，实际是刷新写缓冲区才是真正的第一步完成。      

这里还需注意一点，由于写缓冲区只在自己的处理器可见，它会导致处理器执行操作内存操作的顺序与内存实际操作的顺序执行不一致。     

### 内存屏障指令类型

* loadload barriers
* storestore barriers
* loadstore barriers
* storeload barriers

### happens-before
在jmm中，如果一个操作执行的结果需要对另外操作可见，那么这两个操作之间必须存在happens-before关系，同线程或者多个线程 

  


