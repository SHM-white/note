# java memory model

##  并发编程模型的分类

 > 并发中两个关键问题   
 >1. 线程之间如何通信   
 >2. 线程之间如何同步      
  
通信是指线程之间以何种机制来交换信息，命令式编程中的通信机制主要有两种，共享内存和消息传递    
 
在线程共享的并发模型中 ，线程共享程序的公共状态，线程如何通过读写内存中的公共状态来隐式的通信    
在消息传递的并发模型中，线程之间必须通过明确的的发送消息来显示的通信     
 
同步是指程序用于控制不同线程之间操作发生相对顺序的机制，so 在共享内存并发模式下，同步是显示的，程序员
必须显示指定某个方法或某段代码需要线程之间互斥。在消息传递的并发模型下，由于消息的发送在消息的接收之前，因此
同步是隐式进行的。    

java 使用的共享内存模型，线程之间通信是隐式的，整个通信过程对程序员是透明的

## java内存的模型抽象
首先要知道，在java中 实例域、静态域、数组元素存储在堆上，堆内存在线程之间共享，局部变量，方法定义参数和异常处理参数不会在线程之间
共享，不会存在内存可见性问题，也不受内存模型的影响。

java线程之间通信由jmm (java 内存模型)控制，jmm决定一个线程对共享变量的写入何时对另一个线程可见，抽象角度看jmm定义了线程和主内存
之间的抽象关系：线程之间的共享变量存储在主内存(main memory)中,每一个线程都有一个私有的本地内存(local memory),本地内存
存储了该线程以读/写共享变量的副本。本地缓存是jmm的一个抽象概念，并不真实存在，它涵盖了缓冲，写缓冲区，寄存器以及其他的硬件和编译器优化      
![jmm]()    


## 重排序

什么是重排序？为什么要重新排序？    
程序指令排序，为了提高性能。
分类:   
1. 编译器优化的重排序
       在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序
2. 指令级的重排序
  现代的处理器采用了指令级并行技术来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的顺序
3. 内存系统的重排序
   由于处理使用缓存读和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行      
   
java 从代码到指令排序分别会经历下面三种排序        
!['三种排序']()    
对于编译器，jmm的编译器重排序规则会禁止特定类型的编译器重排序，对于处理器重排序，jmm的重排序规则要求java编译在生成   
指令序列时，插入指定类型的内存屏障，用来禁止指定类型的处理器重排序。

## 处理器重排序和内存屏障指令

现在的处理器使用写缓冲区来临时保存向内存写入的数据，保证指令流水线执行，避免等待写缓存的延时
p-1  a = 1; x =b;   
p-2  b = 1; y =b;   
最后结果就是 x=y=0,具体的1、写缓冲区 2、读共享变量 3、刷新写缓冲区，实际是刷新写缓冲区才是真正的第一步完成。      

这里还需注意一点，由于写缓冲区只在自己的处理器可见，它会导致处理器执行操作内存操作的顺序与内存实际操作的顺序执行不一致。     

### 内存屏障指令类型

* loadload barriers
* storestore barriers
* loadstore barriers
* storeload barriers

### happens-before

在jmm中，如果一个操作执行的结果需要对另外操作可见，那么这两个操作之间必须存在happens-before关系，同线程或者多个线程 

常见的happen-before规则:    
1. 程序顺序股则
2. 监视器规则
3. volatitle变量规则
4. 传递性

# 重排序   

## 数据依赖性  
  定义:  如果两个操作访问同一个变量，且这两个操作y偶一个为写操作，此时这两个操作之间就存在数据依赖性。    
 
* 写后读
 ```
 a = 1;
 b = a;
 ```
* 写后写
```
a = 1;
b = 2;
```

* 读后写
 ```
 a = b;
 a = 2;
 ```
 上面三种情况都会在重排序的情况下，程序的执行结果也会改变。
 
 编译器和处理器不会改变存在数据依赖关系的两个操作执行顺序。
 
 注意:   
 不同处理器之间和不同线程之间的数据依赖性不被编译器和处理考虑  
 
 ## as if  serial 
   不管怎么重排序，程序的执行结果不能被改变，编译器、处理器、runtime都必须遵守    
   为了遵守as-if-serial,编译器和处理器不会对有数据依赖性的操作执行重排序。    
  ```
  double a = 2.3;
  double b = 3.2;
  double area = a*b;
  ```
  as-if-serial 语义把单线程程序保护了起来，遵守a-i-s的编译器，runtime和处理器共同为编写单线程程序的程序员一个假象
  单线程程序的是顺序执行的。    


## 程序顺序规则
 
 在不改变程序执行结果的前提下，尽可能的提高开发并行度。  
 
 
 ## 重排序对多线程的影响
 
 控制依赖性，会影响指令序列的并行度    
 
 单线程中对存在控制依赖的操作重排序，不会改变结果    
 多线程中对存在控制依赖的操作重排序，可能会改变程序的执行结果   
 
 
# 顺序一致性

## 数据竞争与顺序一致性保证

程序未正确同步，会产生数据竞争，具体的定义如下:
* 在一个线程中写一个变量
* 在另一个线程中读同一个变量
* 而且读和写没有使用同步来排序

jmm对正确同步的程序又做了哪些操作呢?
程序的执行将具有顺序一致性 即程序的执行结果与该程序在顺序一致性模型中的执行结果相同，这里的同步指广义上的
同步原语:  synchronized、volatile、final

## 顺序一致性内存模型
特性:   
* 一个线程中的所有操作必须按照程序的顺序来执行
* 所有线程都只能看到一个单一的操作执行顺序，在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见

未同步程序虽然在顺序一致性模型中虽然整体执行顺序是无序的，但是所有线程都只看到一个一致的整体执行顺序。

but 在jmm中就没有这个保证，未同步程序不仅整体执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。

## 同步程序的顺序一致性结果

在顺序一致性模型中，所有操作完全按照程序的顺序串行执行    
在jmm中 在临界区的代码还是可以进行重排序

## 未同步程序的执行特效  
jmm 提供最小安全性 线程执行时读到值，要么是之前写的值，要么是默认值










